///////////////////////////////////////
//
//	Computer Graphics TSBK03
//	Conrad Wahlén - conwa099
//
///////////////////////////////////////

#version 430

layout(local_size_x = 64) in;

struct Particle {
	vec3 position;
	uint bin;
	vec3 velocity;
	uint ID;
};

struct Camera {
	mat4 WTVmatrix;
	mat4 VTPmatrix;
	vec4 normals[8];
	vec4 points[8];
	vec3 position;
	uint padding99;
	vec4 lodLevels;
};

struct Bin {
	uint bins;
	uint totalBins;
	float binSize;
	float areaSize;
};

struct Program {
	float currentT;
	float deltaT;
	float radius;
	float simSpeed;
};

struct Boid {
	float preWeight;
	float cohWeight;
	float sepWeight;
	float aliWeight;
	float fearWeight;
};

layout (std430, binding = 0) writeonly buffer ParticleBuffer1
{
    Particle particlesOut[];  
};

layout (std430, binding = 1) readonly buffer ParticleBuffer2
{
    Particle particlesIn[];  
};

layout (std430, binding = 3) readonly buffer BinCounterBuffer {
	uint binCounter[];
};

layout (std430, binding = 4) readonly buffer PrefixSumBuffer {
	uint prefixSum[];
};

layout (std140, binding = 10) uniform CameraBuffer {
	Camera cam;
};

layout (std140, binding = 11) uniform BinBuffer {
	Bin binInfo;
};

layout (std140, binding = 12) uniform ProgramBuffer {
	Program prog;
};

layout (std140, binding = 13) uniform BoidBuffer {
	Boid boid;
};

Particle tempPart;

void main() {
    uint currentParticle = gl_GlobalInvocationID.x;

	// One global read
	tempPart = particlesIn[currentParticle];

    vec3 pos = tempPart.position;
    vec3 vel = tempPart.velocity;
	uint thisBin = tempPart.bin;
	uint thisID = tempPart.ID;

	// Check that no particles escape!
	if(pos.x < 0) {
		vel.x = abs(vel.x);
	}
	if(pos.y < 0) {
		vel.y = abs(vel.y);
	}
	if(pos.z < 0) {
		vel.z = abs(vel.z);
	}
	if(pos.x > binInfo.areaSize) {
		vel.x = -abs(vel.x);
	}
	if(pos.y > binInfo.areaSize) {
		vel.y = -abs(vel.y);
	}
	if(pos.z > binInfo.areaSize) {
		vel.z = -abs(vel.z);
	}

	// Calculate boid update for all boids in neighbouring bins
	ivec3 pos2id = ivec3(min(max(floor(pos / binInfo.binSize), 0.0f), float(binInfo.bins - 1)));
	ivec3 startID = ivec3(max(pos2id - 1, 0));
	ivec3 endID = ivec3(min(pos2id + 1, binInfo.bins - 1));
	vec3 thatPos, thatVel;
	uint thatID, thatBin, thatIndex;
	float dist, scale;
	uint matches = 0;
	vec3 cohVec = vec3(0.0f), sepVec = vec3(0.0f), aliVec = vec3(0.0f), fearVec = vec3(0.0f);
	vec3 dir;

	int x, y, z, ind;
	for(z = startID.z; z <= endID.z; z++) {
		for(y = startID.y; y <= endID.y; y++) {
			for (x = startID.x; x <= endID.x; x++) {
				thatBin = x + binInfo.bins * y + binInfo.bins * binInfo.bins * z;
				thatIndex = prefixSum[thatBin];
				for (ind = 0; ind < binCounter[thatBin]; ind++){
					thatID = particlesIn[thatIndex + ind].ID;
					thatPos = particlesIn[thatIndex + ind].position;
					thatVel = particlesIn[thatIndex + ind].velocity;
					dist = length(pos - thatPos);

					if(thatID != thisID && dist < binInfo.binSize) {
						matches++;

						cohVec += thatPos;
						
						scale = (dist - binInfo.binSize) / dist;
						dir = normalize(thatPos - pos);
						sepVec += dir * scale;
						
						dir = normalize(thatVel);
						aliVec += dir;
					}
				}
			}
		}
	}

	dist = length(pos - cam.position);
	if(dist < binInfo.binSize) {
		scale = (dist - binInfo.binSize) / dist;
		dir = normalize(cam.position - pos);
		fearVec = normalize(dir * scale) * boid.fearWeight;
	}

	if(matches > 0){
		cohVec /= float(matches);
		cohVec -= pos;

		cohVec = boid.cohWeight * normalize(cohVec);
		sepVec = boid.sepWeight * normalize(sepVec);
		aliVec = boid.aliWeight * normalize(aliVec);
		vel = boid.preWeight * normalize(vel);
		vel = prog.simSpeed * normalize(cohVec + sepVec + aliVec + fearVec + vel);
	}

	tempPart.position = pos + vel * prog.deltaT; // Position update
	tempPart.bin = thisBin; // Keep the bin of the particles
	tempPart.velocity = vel; // Velocity update
	tempPart.ID = thisID; // Keep the ID of the particles

    // Only one global write
	particlesOut[currentParticle] = tempPart;
}