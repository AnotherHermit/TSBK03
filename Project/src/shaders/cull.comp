///////////////////////////////////////
//
//	Computer Graphics TSBK03
//	Conrad Wahlén - conwa099
//
///////////////////////////////////////

#version 430

layout(local_size_x = 64) in;

struct Particle {
	vec3 position;
	uint bin;
	vec3 velocity;
	uint ID;
};

struct Camera {
	mat4 WTVmatrix;
	mat4 VTPmatrix;
	vec4 normals[5];
	vec4 points[5];
	float viewDistance;
	float padding73[3];
};

struct Program {
	float currentT;
	float deltaT;
	float radius;
	float simSpeed;
};

layout (std140, binding = 0) readonly buffer ParticleBuffer
{
    Particle particles[];  
} ;

layout(binding = 2) writeonly buffer CullBuffer {
	float cullPositions[];
};

layout (std140, binding = 10) uniform CameraBuffer {
	Camera cam;
};

layout (std140, binding = 12) uniform ProgramBuffer {
	Program prog;
};

// Atomic counter of rendered particles;
layout(binding = 0) uniform atomic_uint particlesToRender;

void main(void) {
	uint currentParticle = gl_GlobalInvocationID.x;
	uint outParticleNum = 0;

	vec3 pos = particles[currentParticle].position;
	uint bin = particles[currentParticle].bin;
	int i = 0;
	bool keepPoint = true;

	vec3 new_point = pos + cam.normals[i].xyz * prog.radius;
	float distance = dot(new_point, cam.normals[i].xyz) - dot(cam.points[i].xyz, cam.normals[i].xyz);
	keepPoint = (distance > 0);
	i++;
	
	new_point = pos + cam.normals[i].xyz * prog.radius;
	distance = dot(new_point, cam.normals[i].xyz) - dot(cam.points[i].xyz, cam.normals[i].xyz);
	keepPoint = keepPoint && (distance > 0);
	i++;

	new_point = pos + cam.normals[i].xyz * prog.radius;
	distance = dot(new_point, cam.normals[i].xyz) - dot(cam.points[i].xyz, cam.normals[i].xyz);
	keepPoint = keepPoint && (distance > 0);
	i++;

	new_point = pos + cam.normals[i].xyz * prog.radius;
	distance = dot(new_point, cam.normals[i].xyz) - dot(cam.points[i].xyz, cam.normals[i].xyz);
	keepPoint = keepPoint && (distance > 0);
	i++;

	new_point = pos + cam.normals[i].xyz * prog.radius;
	distance = dot(new_point, cam.normals[i].xyz) - dot(cam.points[i].xyz, cam.normals[i].xyz);
	keepPoint = keepPoint && (distance > 0);
	
	if(keepPoint) {
		outParticleNum = atomicCounterIncrement(particlesToRender);
		cullPositions[outParticleNum * 3] = pos.x;
		cullPositions[outParticleNum * 3 + 1] = pos.y;
		cullPositions[outParticleNum * 3 + 2] = pos.z;
	}
}
